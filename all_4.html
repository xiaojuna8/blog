<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
  
  
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="Xcode.html">Xcode</a></li>
        
            <li><a href="Linux.html">Linux</a></li>
        
            <li><a href="Crypt.html">Crypt</a></li>
        
            <li><a href="Computer.html">Computer</a></li>
        
            <li><a href="genome.html">genome</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15173049140539.html">
                
                  <h1>Linux /dev/random</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><a href="https://pthree.org/2014/07/21/the-linux-random-number-generator/"><em>Both /dev/random and /dev/urandom are fed data from the same CSPRNG</em>.</a></p>

<h2 id="toc_0">Structure</h2>

<p><img src="https://gitee.com/uploads/images/2017/1214/113606_fe18dcbf_1453931.png" alt="LinuxRandom" title="LinuxRandom.png"/></p>

<ul>
<li>size of input pool : 128 32-bit words</li>
<li>size of blocking/unblocking pool : 32 32-bit words</li>
</ul>

<h3 id="toc_1">Entropy source</h3>

<ul>
<li>user input like keyboard and mouse movements</li>
<li>disk timing</li>
<li>interrupt timing</li>
</ul>

<p>eachevent contains 3 values</p>

<ul>
<li>a number specific to the event</li>
<li>cycle count</li>
<li>jiffies count (count of time ticks of system timer interrupt)</li>
</ul>

<h3 id="toc_2">noise sources</h3>

<ul>
<li><p>Disk I/O</p>

<ul>
<li>block device +0x100||Jiffies||High-Resolution Timer</li>
<li>Noise derived from access times to spinning pltters</li>
</ul></li>
<li><p>Human Interface Devices(HID)</p></li>
<li><p>Interrupts</p>

<ul>
<li><p>fast pool: 4 32-bit words filled with</p></li>
<li><p>Jiffies</p></li>
<li><p>high resolution timer</p></li>
<li><p>IRQ number</p></li>
<li><p>64 bit Instruction pointer of the CPU</p></li>
</ul></li>
</ul>

<p>The output function is a SHA1 hash run over the output and put in the output pool.</p>

<h2 id="toc_3">MAC Unix noise</h2>

<p>The XUN noise source is implemented solely in software and monitors the interrupt activity of the entire operating system.</p>

<p>The unpredictable phenomenon is the timing of interrupts. </p>

<p><img src="https://gitee.com/uploads/images/2017/1214/155651_da921c32_1453931.png" alt="UnixNoise" title="UnixNoise.png"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/1/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Crypt.html'>Crypt</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15173049140754.html">
                
                  <h1>Linux同步IO</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>原文：<a href="http://www.cnblogs.com/promise6522/archive/2012/05/27/2520028.html">小议同步IO ：fsync与fdatasync</a></p>

<ul>
<li>
<a href="#toc_0">write不够，需要fsync</a>
</li>
<li>
<a href="#toc_1">fsync性能问题</a>
</li>
<li>
<a href="#toc_2">使用fdatasync优化日志同步</a>
</li>
<li>
<a href="#toc_3">fflush &amp; fsync</a>
</li>
<li>
<a href="#toc_4">stackoverflow 上解释 fflush vs fsync</a>
</li>
<li>
<a href="#toc_5">术语</a>
</li>
<li>
<a href="#toc_6">跨平台FTP文件传输</a>
</li>
</ul>


<blockquote>
<p>传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，才进行实际的I/O操作。这种输出方式被称为延迟写（delayed write）（Bach [1986]第3章详细讨论了缓冲区高速缓存）。<br/>
延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，使得欲写到文件中的数据在一段时间内并没有写到磁盘上。当系统发生故障时，这种延迟可能造成文件更新内容的丢失。为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了sync、fsync和fdatasync三个函数。<br/>
sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。<br/>
通常称为update的系统守护进程会周期性地（一般每隔30秒）调用sync函数。这就保证了定期冲洗内核的块缓冲区。命令sync(1)也调用sync函数。<br/>
fsync函数只对由文件描述符filedes指定的单一文件起作用，并且等待写磁盘操作结束，然后返回。fsync可用于数据库这样的应用程序，这种应用程序需要确保将修改过的块立即写到磁盘上。<br/>
fdatasync函数类似于fsync，但它只影响文件的数据部分。而除数据外，fsync还会同步更新文件的属性。</p>

<p>对于提供事务支持的数据库，在事务提交时，都要确保事务日志（包含该事务所有的修改操作以及一个提交记录）完全写到硬盘上，才认定事务提交成功并返回给应用层。</p>
</blockquote>

<h2 id="toc_0">write不够，需要fsync</h2>

<p>一般情况下，对硬盘（或者其他持久存储设备）文件的write操作，更新的只是内存中的页缓存（page cache），而脏页面不会立即更新到硬盘中，而是由操作系统统一调度，如由专门的flusher内核线程在满足一定条件时（如一定时间间隔、内存中的脏页达到一定比例）内将脏页面同步到硬盘上（放入设备的IO请求队列）</p>

<p>因为write调用不会等到硬盘IO完成之后才返回，因此如果OS在write调用之后、硬盘同步之前崩溃，则数据可能丢失。虽然这样的时间窗口很小，但是对于需要保证事务的持久化（durability）和一致性（consistency）的数据库程序来说，write()所提供的“松散的异步语义”是不够的，通常需要OS提供的同步IO（synchronized-IO）原语来保证：</p>

<pre><code class="language-c">#include &lt;unistd.h&gt;
int fsync(int fd);
</code></pre>

<p>fsync的功能是确保文件fd所有已修改的内容已经正确同步到硬盘上，该调用会阻塞等待直到设备报告IO完成。</p>

<p>PS：如果采用内存映射文件的方式进行文件IO（使用mmap，将文件的page cache直接映射到进程的地址空间，通过写内存的方式修改文件），也有类似的系统调用来确保修改的内容完全同步到硬盘之上：</p>

<pre><code class="language-c">#incude &lt;sys/mman.h&gt;
int msync(void *addr, size_t length, int flags)
</code></pre>

<p>msync需要指定同步的地址区间，如此细粒度的控制似乎比fsync更加高效（因为应用程序通常知道自己的脏页位置），但实际上（Linux）kernel中有着十分高效的数据结构，能够很快地找出文件的脏页，使得fsync只会同步文件的修改内容。</p>

<h2 id="toc_1">fsync性能问题</h2>

<p>除了同步文件的修改内容（脏页），fsync还会同步文件的描述信息（<strong>metadata</strong>，包括size、访问时间st_atime &amp; st_mtime等等），因为文件的数据和metadata通常存在硬盘的不同地方，因此fsync至少需要两次IO写操作，fsync的man page这样说：</p>

<blockquote>
<p>&quot;Unfortunately <strong>fsync()</strong> will always initialize two write operations : one for the newly written data and another one in order to update the modification time stored in the inode. If the modification time is not a part of the transaction concept <strong>fdatasync()</strong> can be used to avoid unnecessary inode disk write operations.&quot;</p>
</blockquote>

<p>多余的一次IO操作，有多么昂贵呢？根据<a href="http://en.wikipedia.org/wiki/Disk-drive_performance_characteristics#Seek_time">Wikipedia的数据</a>，当前硬盘驱动的平均寻道时间（Average seek time）大约是3~15ms，7200RPM硬盘的平均旋转延迟（Average rotational latency）大约为4ms，因此一次IO操作的耗时大约为<strong>10ms左右</strong>。</p>

<p>Posix同样定义了fdatasync，放宽了同步的语义以提高性能：</p>

<pre><code class="language-c">#include &lt;unistd.h&gt;
int fdatasync(int fd);
</code></pre>

<p>fdatasync的功能与fsync类似，但是仅仅在必要的情况下才会同步metadata，因此可以减少一次IO写操作。那么，什么是“必要的情况”呢？根据man page中的解释：</p>

<blockquote>
<p>&quot;fdatasync does not flush modified metadata unless that metadata is needed in order to allow a subsequent data retrieval to be corretly handled.&quot;</p>
</blockquote>

<p>举例来说，文件的尺寸（st_size）如果变化，是需要立即同步的，否则OS一旦崩溃，即使文件的数据部分已同步，由于metadata没有同步，依然读不到修改的内容。而最后访问时间(atime)/修改时间(mtime)是不需要每次都同步的，只要应用程序对这两个时间戳没有苛刻的要求，基本无伤大雅。</p>

<h2 id="toc_2">使用fdatasync优化日志同步</h2>

<p>文章开头时已提到，为了满足事务要求，数据库的日志文件是常常需要同步IO的。由于需要同步等待硬盘IO完成，所以事务的提交操作常常十分耗时，成为性能的瓶颈。</p>

<blockquote>
<p>在Berkeley DB下，如果开启了<strong>AUTO_COMMIT</strong>（所有独立的写操作自动具有事务语义）并使用默认的同步级别（日志完全同步到硬盘才返回），写一条记录的耗时大约为<strong>5~10ms</strong>级别，基本和一次IO操作（10ms）的耗时相同。</p>
</blockquote>

<h2 id="toc_3">fflush &amp; fsync</h2>

<blockquote>
<p>fflush:是把C库中的缓冲调用write函数写到磁盘[其实是写到内核的缓冲区]</p>

<p>fsync：是把内核缓冲刷到磁盘上</p>

<p>c库缓冲-----fflush---------〉内核缓冲--------fsync-----〉磁盘</p>
</blockquote>

<h2 id="toc_4">stackoverflow 上解释 fflush vs fsync</h2>

<blockquote>
<p><code>fflush()</code> works on <code>FILE*</code>, it just flushes the internal buffers in the <code>FILE*</code> of your application out to the OS.</p>

<p><code>fsync</code> works on a lower level, it tells the OS to flush its buffers to the physical media.</p>
</blockquote>

<p>OSs heavily cache data you write to a file. If the OS enforced every write to hit the drive, things would be <em>very</em> slow. <code>fsync</code> (among other things) allows you to control when the data should hit the drive.</p>

<h2 id="toc_5">术语</h2>

<p>脏页:linux内核中的概念，因为硬盘的读写速度远赶不上内存的速度，系统就把读写比较频繁的数据事先放到内存中，以提高读写速度，这就叫高速缓存，linux是以页作为高速缓存的单位，当进程修改了高速缓存里的数据时，该页就被内核标记为脏页，内核将会在合适的时间把脏页的数据写到磁盘中去，以保持高速缓存中的数据和磁盘中的数据是一致的。</p>

<p>内存映射：内存映射文件，是由一个文件到一块内存的映射。Win32提供了允许应用程序把文件映射到一个进程的函数 (CreateFileMapping)。内存映射文件与虚拟内存有些类似，通过内存映射文件可以保留一个地址空间的区域，同时将物理存储器提交给此区域，内存文件映射的物理存储器来自一个已经存在于磁盘上的文件，而且在对该文件进行操作之前必须首先对文件进行映射。使用内存映射文件处理存储于磁盘上的文件时，将不必再对文件执行I/O操作，使得内存映射文件在处理大数据量的文件时能起到相当重要的作用。</p>

<h2 id="toc_6">跨平台FTP文件传输</h2>

<blockquote>
<p>通过Linux命令行向在一台Windows FTP服务器上传文件。然后在另一台Windows客户机登录FTP服务器下载，但是下载后的文件大小变了，exe文件错误了不能正确执行。刻意打包的文件（.rar）也提示文件损坏。</p>

<p>这种情况出现了好几次。</p>

<p>经过搜索发现：原来通过linux向ftp服务器上传文件有两种模式 字符模式（ASCII）和二进制模式（Binary）。默认是ASCII模式。一般上传exe文件和压缩包要用二进制模式。</p>

<p>具体操作：</p>

<p>登录ftp后，上传文件前，在ftp&gt;状态下输入bin即可。</p>

<p>然后再put /root/Desktop/test.rar /test.rar 就可以了</p>

<p>注意两个路径都是带文件名的路径，所以这里在上传的同时还有改名的功能。</p>

<p>上传完毕后，用ls检查一下即可。</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/1/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Crypt.html'>Crypt</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15173049141059.html">
                
                  <h1>Linux页缓存</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>原文参考：<a href="http://www.swexception.com/a/linux-unix/linux-unix/2016/1231/2151226.html">Linux页高速缓存跟页回写</a></p>

<ul>
<li>
<a href="#toc_0">缓存手段</a>
<ul>
<li>
<a href="#toc_1">写缓存</a>
</li>
<li>
<a href="#toc_2">缓存回收</a>
<ul>
<li>
<a href="#toc_3">最近最少使用</a>
</li>
<li>
<a href="#toc_4">双链表策略</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_5">flusher线程</a>
</li>
<li>
<a href="#toc_6">查看页缓存大小</a>
</li>
</ul>


<p>页高速缓存(cache memory)是Linux内核实现磁盘缓存。它主要用来减少对磁盘I/O操作。是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。</p>

<p>磁盘高速缓存有两个重要因素：第一，访问磁盘的速度要远低于访问内存的速度，若从处理器L1和L2高速缓存访问则速度更快。第二，数据一旦被访问，就很有可能短时间内再次访问。正是由于基于访问内存比磁盘快的多，所以磁盘的内存缓存将给系统存储性能带来质的飞越。</p>

<blockquote>
<p>文件 Cache 管理指的就是对这些由操作系统分配，并用来存储文件数据的内存的管理。 Cache 管理的优劣通过两个指标衡量：一是 Cache 命中率，Cache 命中时数据可以直接从内存中获取，不再需要访问低速外设，因而可以显著提高性能；二是有效 Cache 的比率，有效 Cache 是指真正会被访问到的 Cache 项，如果有效 Cache 的比率偏低，则相当部分磁盘带宽会被浪费到读取无用 Cache 上，而且无用 Cache 会间接导致系统内存紧张，最后可能会严重影响性能。</p>
</blockquote>

<h2 id="toc_0">缓存手段</h2>

<p>页高速缓存是由内存中的物理页面组成的，其内容对应磁盘上的物理块。页高速缓存大小能动态调整--它可以通过占用空闲内存以扩张大小，也可以自我收缩以缓解内存使用压力。我们称正被缓存的存储设备为后备存储，因为缓存背后的磁盘无疑才是所有缓存数据的归属。当内核开始一个读操作，它首先会检查需要的数据是否在页高速缓存中。如果在则放弃访问磁盘，而直接从内存中读取。这个行为称为缓存命中。如果数据没有在缓存中，称为缓存未命中，那么内核必须调度块I/O操作从磁盘去读取数据。然后内核将读来的数据放入页缓存中，于是任何后续相同的数据读取都可以命中缓存了。系统不一定要将整个文件都缓存，可以缓存文件的一页或几页，到底缓存谁取决于谁被访问到。</p>

<h3 id="toc_1">写缓存</h3>

<p>缓存一般被实现成下面三种策略之一：</p>

<p>第一种策略称为不缓存(nowrite)，也就是说高速缓存不去缓存任何写操作。当对一个缓存中的数据片进行写时，将直接跳过缓存，写到磁盘，同时也使缓存中的数据失效。那么如果后续读操作进行时，需要再重新从磁盘中读取数据。这种策略很少使用。</p>

<p>第二种策略，写操作将自动更新内存缓存，同时也更新磁盘文件。这种方式，通常称为写透缓存（write-through cache），因为写操作会立刻穿透缓存到磁盘中。这种策略对保持缓存一直性很有好处---缓存数据时刻与后备存储保持同步，所以不需要让缓存失效，同时它的实现也最简单。</p>

<p>第三种策略，称为“回写”。在这种策略下，程序执行写操作直接写到缓存中，后端存储不会立刻直接更新，而是将页高速缓存中被写入的页面标记成“脏Dirty”，并且被加入到脏页链表中。然后由一个进程周期性将脏页链表中的页写回到磁盘，从而让磁盘中的数据和内存中最终一致。最后清理“脏”页标识。实际上脏的并不是高速缓存中的数据而是磁盘上的数据（过时了）。更好的描述方式是未同步。通常认为回写策略要好于写透策略。</p>

<h3 id="toc_2">缓存回收</h3>

<p>缓存算法最后涉及的最重要内容是缓存中的数据如何清除，或者是为更重要的缓存项腾出位置，或者是收缩缓存大小。这个工作，也就是决定缓存中什么内容将被清除的策略，称为缓存回收策略。Linux的缓存回收是通过选择干净页进行简单替换。如果缓存中没有足够的干净页面，内核将强制地进行回写操作，以腾出更多的干净可用也。最难的事情在于决定什么页应该回收。理想的回收策略应该是回收那些以后最不可能使用的页面。</p>

<h4 id="toc_3">最近最少使用</h4>

<p>缓存回收策略通过所访问的数据特性，尽量最求预测效率。最成功的算法（特别是对于通用目的的页高速缓存）称作最近最少使用算法，简称LRU。LRU回收策略需要跟踪每个页面的访问踪迹（或者至少按照访问时间为序的页链表），以便能回收最老时间戳的页面（或者回收排序链表头所指的页面）。该策略的良好效果源自于缓存的数据越久未被访问，则越不大可能近期再访问，而最近被访问的最有可能被再次访问。但是LRU策略并非是放之四海皆准的法则，对于许多文件被访问一次，再不被访问的情景，LRU尤其失败。将这些页面放在LRU链表的顶端显然不是最优，当然，内核并没办法知道一个文件只会被访问一次，但是它却知道过去访问了多少次。</p>

<h4 id="toc_4">双链表策略</h4>

<p>Linux实现的是一个修改过的LRU，也称为双链策略。和以前不同，Linux维护的不再是一个LRU链表，而是维护两个链表：活跃链表和非活跃链表。处于活跃链表上的页面被认为是“热”的且不会被换出，而在非活跃链表上的页面则是可以被换出的。在活跃链表中的页面必须在其被访问时就处于非活跃链表中。两个链表都被伪LRU规则维护：页面从尾部加入，从头部移除，如同队列。两个链表需要维持平衡--如果活跃链表变得过多而超过了非活跃链表，那么活跃链表的头页面将被重新移回到非活跃链表中，以便能再被回收。双链表策略解决了传统LRU算法中对仅一次访问的窘境。而且也更加简单的实现了伪LRU语义。这种双链表方式也称作LRU/2。更普遍的是n个链表，故称LRU /n。</p>

<p>假设你正在开发一个很大的软件工程那么你将有大量的源文件被打开，只要你打开读取源文件，这些文件就将被存储在页高速缓存中。只要数据被缓存，那么从一个文件跳到另一个文件将瞬间完成。当编辑文件时，存储文件也会瞬间完成，因为写操作只需要写到内存，而不是磁盘。编译项目时，缓存的文件将使得编译过程更少访问磁盘，所以编译速度也就更快了。如果整个源码树太大了，无法一次性放入内存，那么其中一部分必须被回收--由于双链表策略，任何回收的文件都将处于非活跃链表，而且不大可能是正在编译的文件。在没编译的时候，内核会执行页回写，刷新所修改的文件的磁盘副本。由此可见，缓存将极大地提高系统性能。</p>

<h2 id="toc_5">flusher线程</h2>

<p>由于页高速缓存的缓存作用，写操作实际上会被延迟。当页高速缓存中的数据比后台存储的数据更新时，该数据就称作脏数据。在内存中累积起来的脏页最终被写回磁盘。在以下三种情况发生时，脏页被写回磁盘：</p>

<ul>
<li>当空闲内存低于一个特定阈值时，内核必须将脏页写回磁盘以便释放内存，因为只有干净内存才可以被回收。当内存干净后，内核就可以从缓存清理数据，然后收缩缓存，最终释放出更多内存。</li>
<li>当脏页的内存中驻留时间超过一个特定的阈值时，内核必须将超时的脏页回写磁盘，以确保脏页不会无限期地驻留在内存中。</li>
<li>当用户进程调用sync()和fsync()方法时，内核会按照要求执行回写动作。</li>
</ul>

<p>flusher会被周期的唤醒处理过久的脏页数据。如果系统崩溃，没有来得及写回磁盘的脏页就会丢。</p>

<h2 id="toc_6">查看页缓存大小</h2>

<p>linux上有两种方式查看页缓存大小，一种是free命令，其中cache列卫页缓存大小，单位Byte</p>

<pre><code>free
              total        used        free      shared  buff/cache   available
Mem:      528082808     3969248   499416284       18132    24697276   522514336
Swap:       4194300           0     4194300

//可读性更佳
free -h
              total        used        free      shared  buff/cache   available
Mem:           503G        3.8G        476G         17M         23G        498G
Swap:          4.0G          0B        4.0G
</code></pre>

<p><img src="http://s3.51cto.com/wyfs02/M00/5C/36/wKioL1Uc0aGRKxnJAAHgjMWscjU447.jpg" alt=""/></p>

<p>另一种是直接查看cat /proc/meminfo</p>

<pre><code>MemTotal:       528082808 kB
MemFree:        499415472 kB
MemAvailable:   522513556 kB
Buffers:           24016 kB
Cached:         23712088 kB
SwapCached:            0 kB
Active:         12225912 kB
Inactive:       12290556 kB
Active(anon):     781924 kB
Inactive(anon):    16584 kB
Active(file):   11443988 kB
Inactive(file): 12273972 kB
Unevictable:           0 kB
Mlocked:               0 kB
SwapTotal:       4194300 kB
SwapFree:        4194300 kB
Dirty:                12 kB
Writeback:             0 kB
AnonPages:        780428 kB
Mapped:           108272 kB
Shmem:             18132 kB
Slab:             961268 kB
SReclaimable:     780356 kB
SUnreclaim:       180912 kB
KernelStack:       14736 kB
PageTables:        15840 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:    268235704 kB
Committed_AS:    3061544 kB
VmallocTotal:   34359738367 kB
VmallocUsed:     1144720 kB
VmallocChunk:   34089973756 kB
HardwareCorrupted:     0 kB
AnonHugePages:    577536 kB
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
DirectMap4k:      273152 kB
DirectMap2M:     4874240 kB
DirectMap1G:    533725184 kB
</code></pre>

<ul>
<li><code>Cached</code> — The amount of physical RAM, in kilobytes, used as cache memory.</li>
<li><code>Writeback</code> — The total amount of memory, in kilobytes, actively being written back to the disk.</li>
</ul>

<pre><code>cat /proc/meminfo |grep Dirty
Dirty:            515440 kB

cat /proc/meminfo |grep Write
Writeback:         39396 kB
WritebackTmp:          0 kB
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/1/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Crypt.html'>Crypt</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_3.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_5.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1></h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="Xcode.html"><strong>Xcode</strong></a>
        
            <a href="Linux.html"><strong>Linux</strong></a>
        
            <a href="Crypt.html"><strong>Crypt</strong></a>
        
            <a href="Computer.html"><strong>Computer</strong></a>
        
            <a href="genome.html"><strong>genome</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15173054141309.html">Illumina Sequencing</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15173054141798.html">Illumina二代测序原理</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15173054025402.html">DNA基本关系</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15173053129472.html">字符编码</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15173052079033.html">跨平台C／C++系统／编译器检测</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
